<!DOCTYPE HTML>
<html>
<head>
    <title>Web application - P3</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="../assets/css/main.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
    <noscript><link rel="stylesheet" href="../assets/css/noscript.css" /></noscript>
    <style>
        #map {
            height: 100vh;
            margin-top: 20px;
        }
		.legend {
			background: white;
			line-height: 1.5;
			padding: 6px 8px;
			font: 14px Arial, Helvetica, sans-serif;
			box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
			border-radius: 5px;
			position: absolute; /* Alterado de fixed para absolute */
			bottom: 10px;
			right: 10px;
			z-index: 1000;
		}
        .legend-item {
            margin-bottom: 8px;
        }
        .legend i {
            width: 20px;
            height: 20px;
            float: left;
            margin-right: 8px;
            opacity: 0.6;
        }
        #exportButton {
            background-color: white;
            width: 30px;
            height: 30px;
            text-align: center;
            font-weight: bold;
            color: #555;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #9D9D9D; /* Adicione uma borda verde para corresponder aos botões de desenho */
            border-radius: 5px; /* Arredonde as bordas */
			font-size: 12px;
        }
    </style>
</head>
<body class="is-preload">

    <!-- Wrapper -->
    <div id="wrapper">

        <!-- Header -->
        <header id="header">
            <a href="../index.html" class="logo">Beatriz Mendes</a>
        </header>

        <!-- Nav -->
        <nav id="nav">
            <ul class="links">
                <li><a href="../index.html">Portfolio</a></li>
                <li><a href="../aboutme.html">About Me</a></li>
            </ul>
            <ul class="icons">
                <li><a href="beatrizmendes.github.io" class="icon brands fa-github"><span class="label">GitHub</span></a></li>
                <li><a href="https://www.linkedin.com/in/ana-beatriz-mendes-843424142/" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li>
            </ul>
        </nav>

        <!-- Main -->
        <div id="main">
            <div class="main-content">

            <!-- Post -->
            <section class="post">
                <header class="major">
                    <h2>Geospatial web application for wind farms in Portugal</h2>
                </header>
                <p>This project involves the creation of an interactive map of Portugal using the Leaflet library, combined with various plugins and custom functionalities to provide a comprehensive geospatial visualization tool. The map integrates multiple layers, including vector and raster data, and provides tools for user interaction such as drawing and measuring. Below is a detailed explanation of the key components and functionalities implemented in this project.</p>
                <ol><li> <strong> Custom Icon for Wind Turbines: </strong> A custom icon representing wind turbines is defined and adjusted based on the zoom level to ensure appropriate visibility at different scales. <p></li>
				<li> <strong> Map Initialization: </strong> The map is initialized and centered on Portugal with a predefined zoom level. Several base layers are added, including OpenStreetMap, OpenTopoMap, and Esri World Imagery, providing users with different perspectives and levels of detail. <p></li>
				<li> <strong> Adding GeoJSON Layers: </strong> GeoJSON layers are fetched and added to the map. In this project, two shapefiles are displayed: one for wind turbines and another for electric lines. The wind turbines are represented by the custom icon, and the electric lines are styled with a red line. <p></li>
				<li> <strong> Dynamic Legend: </strong> A dynamic legend is added to the map to help users understand the different layers. The legend updates automatically based on the visible layers. <p></li>
				<li> <strong> Drawing and Measuring Tools: </strong> Tools for drawing various shapes (polylines, polygons, markers, circles, and rectangles) are added to the map, allowing users to interact with the map by creating their own geometries. The drawn shapes can display measurements such as length and area in popups. <p></li>
				<li> <strong> Exporting Data: </strong> An export button is integrated to allow users to download the drawn shapes as KML/KMZ files, enabling further use in other GIS applications. <p></li>
				<li> <strong> Responsive Design: </strong> The map and its components are designed to be responsive, ensuring a good user experience across different devices and screen sizes. <p></li></ol>
                <div id="map"></div> <!-- Div do mapa adicionada -->
            </section>
            <!-- Keywords -->  
            <section>
                <br><p><strong>Keywords:</strong> GIS, Webmap</p>
            </section>
        </div>
    </div>
            <!-- Footer -->
    <footer id="footer">
        <section class="alt">
            <h3>Location</h3>
            <p>Lisbon, Portugal <img src="../images/pt.svg" alt="Portugal Flag" style="width: 20px; height: auto; vertical-align: middle;margin-left: 10px;"></p>
        </section>
        <section>
            <h3>Email</h3>
            <p><a href="mailto:abpmendes@gmail.com">abpmendes@gmail.com</a><br/><a href="mailto:20230919@novaims.unl.pt">20230919@novaims.unl.pt</a></p>
        </section>
        <section>
            <h3>Social</h3>
            <ul class="icons alt">
                <a href="https://github.com/beatrizmendes" class="icon brands fa-github"><span class="label">GitHub</span></a>
                <a href="https://www.linkedin.com/in/ana-beatriz-mendes-843424142/" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a>
            </ul>
        </section>
    </div>
    </footer>
    <!-- Copyright -->
    <div id="copyright">
        <ul>
            <li>&copy; 2024 Beatriz Mendes</li>
        </ul>
    </div>
    
    <!-- Scripts -->
    <script src="../assets/js/jquery.min.js"></script>
    <script src="../assets/js/jquery.scrollex.min.js"></script>
    <script src="../assets/js/jquery.scrolly.min.js"></script>
    <script src="../assets/js/browser.min.js"></script>
    <script src="../assets/js/breakpoints.min.js"></script>
    <script src="../assets/js/util.js"></script>
    <script src="../assets/js/main.js"></script>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://unpkg.com/tokml/tokml.js"></script>
    <script src="https://unpkg.com/leaflet-geometryutil"></script>
    <script>
        // Definir ícone customizado
        var customIcon = L.icon({
            iconUrl: 'iconwindturbine.png',
            iconSize: [16, 16], // Tamanho inicial do ícone
            iconAnchor: [8, 16], // Ponto de ancoragem do ícone (centro inferior)
            popupAnchor: [0, -16] // Ponto de ancoragem do popup (acima do ícone)
        });

        // Função para ajustar o tamanho do ícone com base no nível de zoom
        function adjustIconSize(zoom) {
            var size = Math.max(16, Math.min(32, zoom * 2));
            return L.icon({
                iconUrl: 'iconwindturbine.png',
                iconSize: [size, size],
                iconAnchor: [size / 2, size],
                popupAnchor: [0, -size]
            });
        }

        // Inicialização do mapa
        var map = L.map('map').setView([39.5, -8], 7); // Centrando em Portugal

        // Adicionando camadas de base
        var baseLayers = {
            "OpenStreetMap": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }),
            "OpenStreetMap.HOT": L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Tiles style by <a href="https://www.hotosm.org/" target="_blank">Humanitarian OpenStreetMap Team</a> hosted by <a href="https://openstreetmap.fr/" target="_blank">OpenStreetMap France</a>'
            }),
            "OpenTopoMap": L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, SRTM | Map style: &copy; <a href="https://opentopomap.org/">OpenTopoMap</a> (CC-BY-SA)'
            }), 
            "esriWorldImagery" : L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles © Esri — Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
        }),
    }; 

        baseLayers["OpenStreetMap"].addTo(map);

        // Função para adicionar uma camada GeoJSON ao mapa
        function addGeoJSONLayer(url, style) {
            return fetch(url)
                .then(response => response.json())
                .then(data => L.geoJSON(data, style).bindPopup(function (layer) {
                    return "ID: " + layer.feature.id;
                }));
        }

        // Estilo para as linhas de "Electric Lines"
        var electricLinesStyle = {
            color: 'red',
            weight: 2,
            opacity: 0.6
        };

        // Adicionando as camadas
        var aerLayer, electricLinesLayer;

        Promise.all([
            addGeoJSONLayer('AER_PT.json', {
                pointToLayer: function (feature, latlng) {
                    return L.marker(latlng, { icon: customIcon });
                }
            }),
            addGeoJSONLayer('ElectricLines_PT.json', electricLinesStyle)
        ]).then(layers => {
            aerLayer = layers[0];
            electricLinesLayer = layers[1];

            // Adicionar camada AER ao mapa e ao controle de camadas
            map.addLayer(aerLayer);
            var overlays = {
                "Wind Turbines": aerLayer,
                "Electric Lines": electricLinesLayer
            };

            // Controle de camadas
            L.control.layers(baseLayers, overlays, { collapsed: pageYOffset }).addTo(map);
				
            // Adicionando uma legenda dinâmica
            var legend = L.control({ position: 'bottomright' });

            legend.onAdd = function (map) {
                var div = L.DomUtil.create('div', 'legend');
                var legendContent = '<h4>Legend</h4>';

                // Verificar camadas ativas e adicionar à legenda com o estilo correto
                Object.keys(overlays).forEach(layerName => {
                    var layer = overlays[layerName];
                    if (map.hasLayer(layer)) {
                        var layerStyle = '';
                        if (layer === aerLayer) {
                            layerStyle = `<img src="iconwindturbine.png" width="20" height="20">`;
                        } else if (layer === electricLinesLayer) {
                            layerStyle = `<svg width="20" height="20"><line x1="0" y1="10" x2="20" y2="10" style="stroke:red;stroke-width:2" /></svg>`;
                        }
                        legendContent += `<div class="legend-item">${layerStyle} ${layerName}</div>`;
                    }
                });

                div.innerHTML = legendContent;
                return div;
            };

            legend.addTo(map);

            // Atualizar a legenda quando as camadas mudarem
            map.on('overlayadd overlayremove', function (event) {
                legend.remove();
                legend.addTo(map);
            });

            // Atualizar ícones de marcadores de aerogeradores com base no nível de zoom
            map.on('zoomend', function () {
                aerLayer.eachLayer(function (layer) {
                    layer.setIcon(adjustIconSize(map.getZoom()));
                });
            });

        }).catch(error => {
            console.error("Erro ao carregar camadas:", error);
        });

        // Adicionar ferramenta de desenho e medição
        var drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        var drawControl = new L.Control.Draw({
            edit: {
                featureGroup: drawnItems,
                edit: true
            },
            draw: {
                polyline: {
                    shapeOptions: {
                        color: 'blue'
                    }
                },
                polygon: {
                    allowIntersection: false,
                    showArea: true,
                    drawError: {
                        color: 'orange',
                        timeout: 1000
                    },
                    shapeOptions: {
                        color: 'green'
                    }
                },
                marker: {
                    icon: L.divIcon({
                        className: 'leaflet-div-icon',
                        iconSize: [10, 10],
                        html: '<div style="background-color: blue; width: 10px; height: 10px; border-radius: 50%;"></div>'
                    }),
                    title: 'draw a point'
                },
                circlemarker: false,
                circle: {
                    shapeOptions: {
                        color: 'purple'
                    },
                    title: 'draw a buffer'
                },
                rectangle: {
                    shapeOptions: {
                        color: 'black'
                    }
                }
            }
        });
        map.addControl(drawControl);

        // Adicionando botão de exportação integrado
        var exportButton = L.Control.extend({
            options: {
                position: 'topleft' // Coloca o botão na mesma posição dos botões de desenho
            },
            onAdd: function (map) {
                var container = L.DomUtil.create('a', 'leaflet-bar leaflet-control', document.body);
                container.id = 'exportButton'; // Adiciona o id ao botão
                container.title = 'Export KML/KMZ';
                container.innerHTML = 'KML'; // Adiciona o texto "KML"
                container.onclick = function() {
                    exportKML();
                }
                return container;
            }
        });
        map.addControl(new exportButton());

        map.on(L.Draw.Event.CREATED, function (event) {
            var layer = event.layer;
            drawnItems.addLayer(layer);
            var type = event.layerType;
            var popupContent = "";

            if (type === 'polyline') {
                var length = L.GeometryUtil.length(layer);
                popupContent = 'Comprimento: ' + (length / 1000).toFixed(2) + ' km';
            } else if (type === 'polygon') {
                var area = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
                popupContent = 'Área: ' + (area / 1000000).toFixed(2) + ' km²';
            } else if (type === 'polygon') {
                var area = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
                popupContent = 'Área: ' + (area / 1000000).toFixed(2) + ' km²';
            } else if (type === 'rectangle') {
                var area = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
                popupContent = 'Área: ' + (area / 1000000).toFixed(2) + ' km²';
            } else if (type === 'circle') {
                var radius = layer.getRadius();
                popupContent = 'Buffer Radius: ' + (radius / 1000).toFixed(2) + ' km';
            } else if (type === 'marker') {
                popupContent = 'Ponto adicionado';
            }
            
            layer.bindPopup(popupContent).openPopup();
        });

        map.on('draw:edited', function (event) {
            var layers = event.layers;
            layers.eachLayer(function (layer) {
                var type = layer instanceof L.Polyline ? 'polyline' : (layer instanceof L.Polygon ? 'polygon' : 'other');
                var popupContent = "";

                if (type === 'polyline') {
                    var length = L.GeometryUtil.length(layer);
                    popupContent = 'Comprimento: ' + (length / 1000).toFixed(2) + ' km';
                } else if (type === 'polygon') {
                    var area = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
                    popupContent = 'Área: ' + (area / 1000000).toFixed(2) + ' km²';
                }
                
                layer.setPopupContent(popupContent).openPopup();
            });
        });

        // Função para converter um círculo em um polígono GeoJSON
        function circleToPolygon(circle, points) {
            var center = circle.getLatLng();
            var radius = circle.getRadius();
            var latlngs = [];
            for (var i = 0; i < points; i++) {
                var angle = (i / points) * 360;
                var latlng = L.GeometryUtil.destination(center, angle, radius);
                latlngs.push(latlng);
            }
            return L.polygon(latlngs, circle.options).toGeoJSON();
        }

        // Função para exportar os shapes desenhados como KML/KMZ
        function exportKML() {
            var geojson = drawnItems.toGeoJSON();
            var features = geojson.features.map(function(feature) {
                if (feature.geometry.type === 'Point' && feature.properties.title === 'draw a buffer') {
                    var bufferLayer = drawnItems.getLayers().find(function(layer) {
                        return layer.feature === feature;
                    });
                    if (bufferLayer) {
                        return circleToPolygon(bufferLayer, 64);
                    }
                }
                return feature;
            });
            var kml = tokml({ type: 'FeatureCollection', features: features });
            var blob = new Blob([kml], {type: 'application/vnd.google-earth.kmz'});
            var url = URL.createObjectURL(blob);
            var link = document.createElement('a');
            link.href = url;
            link.download = 'shapes.kmz';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        document.getElementById('exportKML').addEventListener('click', exportKML);
    </script>
</body>
</html>
